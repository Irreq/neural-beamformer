#include <stdio.h>
#include <string.h>
#include <math.h>

#define N_SAMPLES 1024
#define AVX_SIMD_LENGTH 8
#define ALIGNMENT 32

#define X_SCAN 50
#define Y_SCAN 20
#define N_MICROPHONES 64

#include <immintrin.h>

void quick_derp_delay_add___(float *signal, float *out, int n_frames, float fraction)
{
    // const int N_SAMPLES = 1024; // Assuming N_SAMPLES is a constant value

    // Align the signal and out arrays
    float *aligned_signal = (float *)_mm_malloc(N_SAMPLES * sizeof(float), 32);
    float *aligned_out = (float *)_mm_malloc(N_SAMPLES * sizeof(float), 32);

    // Copy the original data to the aligned arrays
    memcpy(aligned_signal, signal, N_SAMPLES * sizeof(float));
    memcpy(aligned_out, out, N_SAMPLES * sizeof(float));

    int i = 0;

    // Process 8 samples at a time using AVX2
    for (; i < N_SAMPLES - n_frames - 8; i += 8)
    {
        __m256 in1 = _mm256_load_ps(aligned_signal + i);
        __m256 in2 = _mm256_load_ps(aligned_signal + i + 1);
        __m256 diff = _mm256_sub_ps(in1, in2);
        __m256 frac = _mm256_set1_ps(fraction);
        __m256 interp = _mm256_fmadd_ps(frac, diff, in1);
        __m256 outv = _mm256_load_ps(aligned_out + i + n_frames);
        outv = _mm256_add_ps(outv, interp);
        _mm256_store_ps(aligned_out + i + n_frames, outv);
    }

    // Process the remaining samples (less than 8)
    for (; i < N_SAMPLES - n_frames - 1; i++)
    {
        aligned_out[i + n_frames] += aligned_signal[i] + fraction * (aligned_signal[i] - aligned_signal[i + 1]);
    }

    aligned_out[N_SAMPLES - 1] = aligned_signal[N_SAMPLES - 1 - n_frames];

    // Copy the aligned data back to the original arrays
    memcpy(out, aligned_out, N_SAMPLES * sizeof(float));

    // Free the aligned memory
    _mm_free(aligned_signal);
    _mm_free(aligned_out);

    // out[n_frames] = signal[0];
}

void quick_derp_delay_add__(float *signal, float *out, int n_frames, float fraction)
{
    // const int N_SAMPLES = 1024; // Assuming N_SAMPLES is a constant value

    int i = 0;

    __m256 frac = _mm256_set1_ps(fraction);
    __m256 in1, in2, diff, interp, outv;

    // Process 8 samples at a time using AVX2
    for (; i < N_SAMPLES - n_frames - 8; i += 8)
    {
        in1 = _mm256_loadu_ps(signal + i);
        in2 = _mm256_loadu_ps(signal + i + 1);
        diff = _mm256_sub_ps(in1, in2);
        
        interp = _mm256_fmadd_ps(frac, diff, in1);
        outv = _mm256_loadu_ps(out + i + n_frames);
        outv = _mm256_add_ps(outv, interp);
        _mm256_storeu_ps(out + i + n_frames, outv);
    }

    // Process the remaining samples (less than 8)
    for (; i < N_SAMPLES - n_frames - 1; i++)
    {
        out[i + n_frames] += signal[i] + fraction * (signal[i] - signal[i + 1]);
    }

    out[N_SAMPLES - 1] = signal[N_SAMPLES - 1 - n_frames];

    // out[n_frames] = signal[0];
}

void quick_derp_delay_add_(float *signal, float *out, int n_frames, float fraction)
{
    for (int i = 0; i < N_SAMPLES - n_frames - 1; i++)
    {
        out[i + n_frames] += signal[i] + fraction * (signal[i] - signal[i + 1]);
    }

    out[N_SAMPLES - 1] = signal[N_SAMPLES - 1 - n_frames];

    // out[n_frames] = signal[0];
}

void blazing_mimo(float *signal, float *image, float *antenna)
{
    // double fraction;
    // double integer = modf(number, &fraction);

    double fraction, frame;

    float _out[N_SAMPLES] = {0.0};

    float *out = &_out[0];

    int n_frames;
    int pos;

    for (int y = 0; y < Y_SCAN; y++)
    {
        for (int x = 0; x < X_SCAN; x++)
        {
            memset(out, 0, N_SAMPLES * sizeof(float));
            for (int n = 0; n < N_MICROPHONES; n++)
            {
                pos = y * X_SCAN * N_MICROPHONES + x * N_MICROPHONES + n;

                fraction = modf(antenna[pos], &frame);
                n_frames = (int)frame;
                for (int i = 0; i < N_SAMPLES - n_frames; i++)
                {
                    out[i + n_frames] += (signal[n * N_SAMPLES + i] + fraction * (signal[n * N_SAMPLES + i] - signal[n * N_SAMPLES + i + 1])) / N_MICROPHONES;
                }
                out[N_SAMPLES - 1] += signal[N_SAMPLES - 1 - n_frames + n * N_SAMPLES] / N_MICROPHONES;
            }

            image[y * X_SCAN + x] = 0.0;
            for (int k = 0; k < N_SAMPLES; k++)
            {
                image[y * X_SCAN + x] += powf(out[k], 2);
            }

            image[y * X_SCAN + x] /= (float)N_SAMPLES;
        }
        
    }
    
}

// void vector_derp(float *signal, float *out, int n_frames, float fraction)
// {
//     for (int i = 0; i < N_SAMPLES - AVX_SIMD_LENGTH; i += AVX_SIMD_LENGTH)
//     {
//         /* code */
//     }
    
// }

#include <time.h>
#include <stdio.h>

#define N_TIMES 40

int main(int argc, char const *argv[])
{
    float signal[N_SAMPLES * N_MICROPHONES] = {0.0};

    for (int i = 0; i < N_SAMPLES * N_MICROPHONES; i++)
    {
        signal[i] = (float)i / 2 + 1;
    }

    float image[X_SCAN * Y_SCAN] = {0.0};

    float antenna[X_SCAN * Y_SCAN * N_MICROPHONES] = { 0.0 };

    for (int i = 0; i < X_SCAN * Y_SCAN * N_MICROPHONES; i++)
    {
        antenna[i] = (float)i/(X_SCAN * Y_SCAN);
    }
    

    clock_t start = clock();
    for (int i = 0; i < N_TIMES; i++)
    {
        /* code */
        blazing_mimo(&signal[0], &image[0], &antenna[0]);
    }

    clock_t stop = clock();

    // for (int i = 0; i < N_SAMPLES; i++)
    // {
    //     printf("%f %f\n", signal[i], out[i]);
    // }

    double elapsed = (double)(stop - start) / CLOCKS_PER_SEC / N_TIMES;
    printf("Time elapsed in ms: %f\n", elapsed);

    double number = 1.3;
    double integer;
    double fraction = (float)modf(number, &integer);

    printf("Integer part: %.0f\n", integer);
    printf("Fractional part: %.1f\n", fraction);

    return 0;
}

// int main(int argc, char const *argv[])
// {
//     float signal[N_SAMPLES] = {0.0};

//     for (int i = 0; i < N_SAMPLES; i++)
//     {
//         signal[i] = (float)i / 2 + 1;
//     }
    

//     float out[N_SAMPLES] = {0.0};

//     clock_t start = clock();
//     for (int i = 0; i < N_TIMES; i++)
//     {
//         /* code */
//         quick_derp_delay_add__(&signal[0], &out[0], 0, 0.0);
//     }
    
    
//     clock_t stop = clock();

//     // for (int i = 0; i < N_SAMPLES; i++)
//     // {
//     //     printf("%f %f\n", signal[i], out[i]);
//     // }

    
//     double elapsed = (double)(stop - start) * 1000.0 / CLOCKS_PER_SEC;
//     printf("Time elapsed in ms: %f\n", elapsed);

//     double number = 1.3;
//     double integer;
//     double fraction = (float)modf(number, &integer);

//     printf("Integer part: %.0f\n", integer);
//     printf("Fractional part: %.1f\n", fraction);

//     return 0;
// }
