#include <stdio.h>
#include <string.h>
#include <math.h>

#define N_SAMPLES 1024
#define AVX_SIMD_LENGTH 8
#define ALIGNMENT 32

#define X_SCAN 50
#define Y_SCAN 20
#define N_MICROPHONES 64

#include <immintrin.h>

void quick_derp_delay_add___(float *signal, float *out, int n_frames, float fraction)
{
    // const int N_SAMPLES = 1024; // Assuming N_SAMPLES is a constant value

    // Align the signal and out arrays
    float *aligned_signal = (float *)_mm_malloc(N_SAMPLES * sizeof(float), 32);
    float *aligned_out = (float *)_mm_malloc(N_SAMPLES * sizeof(float), 32);

    // Copy the original data to the aligned arrays
    memcpy(aligned_signal, signal, N_SAMPLES * sizeof(float));
    memcpy(aligned_out, out, N_SAMPLES * sizeof(float));

    int i = 0;

    // Process 8 samples at a time using AVX2
    for (; i < N_SAMPLES - n_frames - 8; i += 8)
    {
        __m256 in1 = _mm256_load_ps(aligned_signal + i);
        __m256 in2 = _mm256_load_ps(aligned_signal + i + 1);
        __m256 diff = _mm256_sub_ps(in1, in2);
        __m256 frac = _mm256_set1_ps(fraction);
        __m256 interp = _mm256_fmadd_ps(frac, diff, in1);
        __m256 outv = _mm256_load_ps(aligned_out + i + n_frames);
        outv = _mm256_add_ps(outv, interp);
        _mm256_store_ps(aligned_out + i + n_frames, outv);
    }

    // Process the remaining samples (less than 8)
    for (; i < N_SAMPLES - n_frames - 1; i++)
    {
        aligned_out[i + n_frames] += aligned_signal[i] + fraction * (aligned_signal[i] - aligned_signal[i + 1]);
    }

    aligned_out[N_SAMPLES - 1] = aligned_signal[N_SAMPLES - 1 - n_frames];

    // Copy the aligned data back to the original arrays
    memcpy(out, aligned_out, N_SAMPLES * sizeof(float));

    // Free the aligned memory
    _mm_free(aligned_signal);
    _mm_free(aligned_out);

    // out[n_frames] = signal[0];
}

void quick_derp_delay_add__(float *signal, float *out, int n_frames, float fraction)
{
    // const int N_SAMPLES = 1024; // Assuming N_SAMPLES is a constant value

    int i = 0;

    __m256 frac = _mm256_set1_ps(fraction);
    __m256 in1, in2, diff, interp, outv;

    // Process 8 samples at a time using AVX2
    for (; i < N_SAMPLES - n_frames - 8; i += 8)
    {
        in1 = _mm256_loadu_ps(signal + i);
        in2 = _mm256_loadu_ps(signal + i + 1);
        diff = _mm256_sub_ps(in1, in2);
        
        interp = _mm256_fmadd_ps(frac, diff, in1);
        outv = _mm256_loadu_ps(out + i + n_frames);
        outv = _mm256_add_ps(outv, interp);
        _mm256_storeu_ps(out + i + n_frames, outv);
    }

    // Process the remaining samples (less than 8)
    for (; i < N_SAMPLES - n_frames - 1; i++)
    {
        out[i + n_frames] += signal[i] + fraction * (signal[i] - signal[i + 1]);
    }

    out[N_SAMPLES - 1] = signal[N_SAMPLES - 1 - n_frames];

    // out[n_frames] = signal[0];
}

void quick_derp_delay_add_(float *signal, float *out, int n_frames, float fraction)
{
    for (int i = 0; i < N_SAMPLES - n_frames - 1; i++)
    {
        out[i + n_frames] += signal[i] + fraction * (signal[i] - signal[i + 1]);
    }

    out[N_SAMPLES - 1] = signal[N_SAMPLES - 1 - n_frames];

    // out[n_frames] = signal[0];
}

void blazing_mimo(float *signal, float *image, float *antenna)
{
    // double fraction;
    // double integer = modf(number, &fraction);

    double fraction, frame;

    float _out[N_SAMPLES] = {0.0};

    float *out = &_out[0];

    int n_frames;
    int pos;

    for (int y = 0; y < Y_SCAN; y++)
    {
        for (int x = 0; x < X_SCAN; x++)
        {
            memset(out, 0, N_SAMPLES * sizeof(float));
            for (int n = 0; n < N_MICROPHONES; n++)
            {
                pos = y * X_SCAN * N_MICROPHONES + x * N_MICROPHONES + n;

                fraction = modf(antenna[pos], &frame);
                n_frames = (int)frame;
                for (int i = 0; i < N_SAMPLES - n_frames; i++)
                {
                    out[i + n_frames] += (signal[n * N_SAMPLES + i] + fraction * (signal[n * N_SAMPLES + i] - signal[n * N_SAMPLES + i + 1])) / N_MICROPHONES;
                }
                out[N_SAMPLES - 1] += signal[N_SAMPLES - 1 - n_frames + n * N_SAMPLES] / N_MICROPHONES;
            }

            image[y * X_SCAN + x] = 0.0;
            for (int k = 0; k < N_SAMPLES; k++)
            {
                image[y * X_SCAN + x] += powf(out[k], 2);
            }

            image[y * X_SCAN + x] /= (float)N_SAMPLES;
        }
        
    }
    
}

// void vector_derp(float *signal, float *out, int n_frames, float fraction)
// {
//     for (int i = 0; i < N_SAMPLES - AVX_SIMD_LENGTH; i += AVX_SIMD_LENGTH)
//     {
//         /* code */
//     }
    
// }

#include <time.h>
#include <stdio.h>

#define N_TIMES 40

int main(int argc, char const *argv[])
{
    float signal[N_SAMPLES * N_MICROPHONES] = {0.0};

    for (int i = 0; i < N_SAMPLES * N_MICROPHONES; i++)
    {
        signal[i] = (float)i / 2 + 1;
    }

    float image[X_SCAN * Y_SCAN] = {0.0};

    float antenna[X_SCAN * Y_SCAN * N_MICROPHONES] = { 0.0 };

    for (int i = 0; i < X_SCAN * Y_SCAN * N_MICROPHONES; i++)
    {
        antenna[i] = (float)i/(X_SCAN * Y_SCAN);
    }
    

    clock_t start = clock();
    for (int i = 0; i < N_TIMES; i++)
    {
        /* code */
        blazing_mimo(&signal[0], &image[0], &antenna[0]);
    }

    clock_t stop = clock();

    // for (int i = 0; i < N_SAMPLES; i++)
    // {
    //     printf("%f %f\n", signal[i], out[i]);
    // }

    double elapsed = (double)(stop - start) / CLOCKS_PER_SEC / N_TIMES;
    printf("Time elapsed in ms: %f\n", elapsed);

    double number = 1.3;
    double integer;
    double fraction = (float)modf(number, &integer);

    printf("Integer part: %.0f\n", integer);
    printf("Fractional part: %.1f\n", fraction);

    return 0;
}

// int main(int argc, char const *argv[])
// {
//     float signal[N_SAMPLES] = {0.0};

//     for (int i = 0; i < N_SAMPLES; i++)
//     {
//         signal[i] = (float)i / 2 + 1;
//     }
    

//     float out[N_SAMPLES] = {0.0};

//     clock_t start = clock();
//     for (int i = 0; i < N_TIMES; i++)
//     {
//         /* code */
//         quick_derp_delay_add__(&signal[0], &out[0], 0, 0.0);
//     }
    
    
//     clock_t stop = clock();

//     // for (int i = 0; i < N_SAMPLES; i++)
//     // {
//     //     printf("%f %f\n", signal[i], out[i]);
//     // }

    
//     double elapsed = (double)(stop - start) * 1000.0 / CLOCKS_PER_SEC;
//     printf("Time elapsed in ms: %f\n", elapsed);

//     double number = 1.3;
//     double integer;
//     double fraction = (float)modf(number, &integer);

//     printf("Integer part: %.0f\n", integer);
//     printf("Fractional part: %.1f\n", fraction);

//     return 0;
// }

void interp_naive(int *signal, int *out, int amount)
{
    int mod = amount % 2;
    int n_samples = amount - mod;

    if (amount == 1)
    {
        n_samples = 1;
    }

    memset(out, 0, sizeof(int) * n_samples);
    if (mod == 1)
    {
        for (int i = 1; i < N_SAMPLES - n_samples; i++)
        {
            out[n_samples + i - 1] = signal[i - 1] + ((signal[i] - signal[i - 1]) >> 1);
        }
        out[N_SAMPLES - 1] = signal[N_SAMPLES - n_samples - 1];
    }
    else
    {
        memcpy(out + n_samples, signal, sizeof(int) * (N_SAMPLES - n_samples));
    }
}

void interp_avx_prefetch(int *signal, int *out, int amount)
{
    int mod = amount % 2;
    int n_samples = amount - mod;

    if (amount == 1)
    {
        n_samples = 1;
    }

    memset(out, 0, sizeof(int) * n_samples);

    if (mod == 1) {
        __m256i v0 = _mm256_setzero_si256();
        __m256i v1 = _mm256_setzero_si256();

        __m256i diff = _mm256_setzero_si256();

        int i = 0;
        for (; i < N_SAMPLES - 8; i+=8)
        {
            _mm_prefetch((char *)(signal + i + 9*2), _MM_HINT_T0);
            v0 = _mm256_loadu_si256((__m256i *)(signal + i));
            v1 = _mm256_loadu_si256((__m256i *)(signal + i + 1));

            diff = _mm256_sub_epi32(v1, v0);
            diff = _mm256_srai_epi32(diff, 1);
            diff = _mm256_add_epi32(v0, diff);

            _mm256_storeu_si256((__m256i *)(out + mod + i), diff);
        }

        // Last in a naive way
        for (; i < N_SAMPLES;i++)
        {
            out[n_samples + i - 2] = signal[i - 1] + ((signal[i] - signal[i - 1]) >> 1);
        }
        out[N_SAMPLES - 1] = signal[N_SAMPLES - n_samples - 1];

    } else {
        memcpy(out + n_samples, signal, sizeof(int) * (N_SAMPLES - n_samples));
    }
}

void interp_avx(int *signal, int *out, int amount)
{
    int mod = amount % 2;
    int n_samples = amount - mod;

    if (amount == 1)
    {
        n_samples = 1;
    }

    memset(out, 0, sizeof(int) * n_samples);

    if (mod == 1)
    {
        __m256i v0 = _mm256_setzero_si256();
        __m256i v1 = _mm256_setzero_si256();

        __m256i diff = _mm256_setzero_si256();

        int i = 0;
        for (; i < N_SAMPLES - 8; i += 8)
        {
            v0 = _mm256_loadu_si256((__m256i *)(signal + i));
            v1 = _mm256_loadu_si256((__m256i *)(signal + i + 1));

            diff = _mm256_sub_epi32(v1, v0);
            diff = _mm256_srai_epi32(diff, 1);
            diff = _mm256_add_epi32(v0, diff);

            _mm256_storeu_si256((__m256i *)(out + mod + i), diff);
        }

        // Last in a naive way
        for (; i < N_SAMPLES; i++)
        {
            out[n_samples + i - 2] = signal[i - 1] + ((signal[i] - signal[i - 1]) >> 1);
        }
        out[N_SAMPLES - 1] = signal[N_SAMPLES - n_samples - 1];
    }
    else
    {
        memcpy(out + n_samples, signal, sizeof(int) * (N_SAMPLES - n_samples));
    }
}

#include <time.h>


#define N_TIMES 1000000

int main()
{
    __m256i vec = _mm256_set_epi32(16, 8, 0, 8, 16, 32, 64, 1024);
    __m128i shiftCount = _mm_set1_epi32(4);
    // __m128i shiftCount = _mm_set_epi32(1, 1, 1, 1);

    // __m128i shiftCount = ( __m128i)1;

    // printf("Before shift:\n");
    // print256(vec);

    // // __m256i result = _mm256_sra_epi32(vec, shiftCount);
    // // __m256i result = _mm256_srlv_epi32(vec, shiftCount);
    // __m256i result = _mm256_srai_epi32(vec, 1);

    

    // // _mm256_storeu_si256()
    

    // printf("After shift:\n");
    // print256(result);

    // int signal[9] = {16, 8, 0, 8, 16, 32, 64, 128, 256};
    int out[N_SAMPLES];

    int signal[N_SAMPLES];

    for (int i = 0; i < N_SAMPLES; i++)
    {
        signal[i] = (int)pow((double)(i+1), 1.9);
    }

    clock_t start, stop;
    start = clock();
    for (int i = 0; i < N_TIMES; i++)
    {
        interp_avx(&signal[0], &out[0], (i + 1) % 5);
    }
    stop = clock();

    double elapsed = (double)(stop - start) / CLOCKS_PER_SEC;
    printf("Vectorized Time elapsed in ms: %f\n", elapsed);

    start = clock();
    for (int i = 0; i < N_TIMES; i++)
    {
        interp_naive(&signal[0], &out[0], (i+1)%5);
    }
    stop = clock();

    elapsed = (double)(stop - start) / CLOCKS_PER_SEC;
    printf("Naive Time elapsed in ms: %f\n", elapsed);

    interp_naive(&signal[0], &out[0], 1);

    // for (int i = 0; i < N_SAMPLES; i++)
    // {
    //     printf("%d %d\n", signal[i], out[i]);
    // }
    // printf("\n");

    return 0;
}
